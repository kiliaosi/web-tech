<!--
 * @Author: kiliaosi
 * @Date: 2020-07-30 16:46:53
 * @LastEditors: kiliaosi
 * @LastEditTime: 2020-08-05 21:00:14
 * @Description:
-->
# 传输层
## 运输层的学习，一定要完成如下目标：
- 1： 运输层为相互通信的进程提供逻辑通信
- 2： 端口和套接字的意义
- 3： 无连接的UDP的特点
- 4： 面向连接的TCP的特点
- 5： 在不可靠的网络上实现可靠传输的原理（停止等待协议，ARQ协议）
- 6： TCP流量控制，拥塞控制，滑动窗口，连接管理。

> 运输层向它上面的应用层提供通信服务

- 宏观上看，网络通信是两台主机之间的通信，由网络层提供逻辑通信；
- 真正通信的是由两台计算机之中的进程来进行的。进程之间的逻辑通信由传输层实现

## UDP
- UDP是无连接的，在发送/接收数据之前不需要建立连接
- UDP是不可靠的，尽最大努力交付数据，主机之间无需要维护连接状态
- UDP面向报文，在应用层交给它报文时，它既不合并，也不拆分，打上UDP首部尾部后就将数据包交给网络层，而接收端UDP协议在收到UDP包之后，剥离了UDP首部尾部后就直接将数据交付给应用进程。
> 由于UDP协议不会主动处理交付给它的数据（比如将较大的报文拆分成较小的报文，将较小的报文，组合成较大的报文后，在发送出去），所以在将数据交给UDP协议处理之前，应该由进程自己把握好报文大小。否则就算是UDP不会分包，在UDP将报文交给IP层时，IP层就会进行报文分片，从而降低IP层的效率。
- UDP没有拥塞控制，就算网络发生了拥塞，也不会降低源主机的发送速率。（很多应用需要这个特性，比如视频会议，直播）
- UDP支持的通信模式：一对一， 一对多，多对一， 多对多。
- UDP的首部较小（开销小），只有8个字节，而TCP需要20个字节
> 很多应用都需要无拥塞控制的UDP协议，但当大量的应用都在往网络中发送UDP报文时，可能会造成网络拥塞，结果最后大家都在疯狂丢包。（不使用拥塞控制的UDP协议可能会引发严重的网络拥塞）
> 在UDP的使用场景，很多都会对UDP协议进行改进（一般在传输层上层进行），增加少许的拥塞控制。


### UDP首部格式
源端口|目的端口|长度|检验和
> 上述结构每个段占用两个字节，总共8个字节。

1) 源端口：需要对方回复时将本地端口号发送给对方，如果不需要时，以0占位
2) 目的端口：数据到达目的地时，需要将数据交付时必须用到。
3) 长度，UDP用户数据报的长度，最小为8（即只有首部）
4) 检验和，检查UDP数据报在传输中是否有错误，如果有错就丢弃。
> 如果目的端UDP协议在交付数据的时候，没有发现对应端口号的进程，那么就会丢弃该报文，并由ICMP发送端口不可达差错报文给对方。

# TCP
- TCP协议是面向连接的，所以在发送报文之前，必须建立TCP连接，在通信完成之后，必须释放连接。
- 每一个TCP连接只有两个端点，只支持一对一通信
- TCP提供可靠的通信（无差错，不丢失，不重复，按序到达）
- TCP提供全双工通信。允许连接的双方进程在任何时候都能发送数据。连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序将数据交给TCP缓存后，就可以不管了。接收时，TCP把接收到的数据放入缓存，上层应用程序在合适的时候读取缓存中的数据。
- 面向字节流，流（stream）是指流入到进程或从进程流出的字节序列。

## 套接字（socket）
> 根据RFC793的定义，端口号拼接到ip后面即为套接字。
socket = (IP:PORT)

由上可以得到：
TCP连接 ::= {(IP1:PORT1), (IP2:PORT2)};
> 套接字是一个很抽象的概念，我们为了方便描述，大多数会说：在两个进程之间建立了一条TCP连接。但是TCP连接的两个端点是：套接字。同一个IP地址，可以有多个不同的TCP连接，而同一个端口号也可以出现在多个不同的TCP连接中。


## 可靠传输的工作原理
- 理想状态下，可靠传输应该具有以下特征
1) 传输信道不产生差错
2) 不管对方以多块的速度发送数据，接收方总能正确接受并处理
> 从物理层到网络层提供的都是不可靠的服务，要想在这些不可靠的服务基础上构建可靠的通信，需要做一些处理， 比如说：数据出了差错就让对方重传，数据来不及处理的时候要告知对方降低数据发送速率。

### 停止等待协议
> TCP提供全双工通信，这样一来，通信双方既是接收方也是发送方。为了保证数据能正确到达，需要做如下处理：
例：现有通信双方M1, M2. 现在M1有2个分组需要发送到M2（看作理想状态，分组不会出错）
- M1 -msg-> M2 ;
- M1等待M2 确认分组接收；
- M1 <-ACK- M2;
- M1收到确认，发送第二个分组
- M1 -msg-> M2
- M1等待M2 确认分组接收；
- M1 <-ACK- M2;

 以上的流程讨论的是不出现差错的情况，理想状态下的传输。但在实际应用中，丢包，包出错是常有的事。 而M1 M2 对这种情况会怎么处理呢?

 如果说： M1 给M2发送的第一个分组，出现了差错: M2会直接将分组丢弃，然后什么也不会做。 而M1在超时之后，会重发第一个分组，继续上面的流程。 这里有一个疑问，为什么M2 不发送一个失败的消息给对方呢？ 这么想一下，如果说第一个分组不是出现了差错，而是在传输过程中，被丢弃了，怎么办呢， M2是不知道的。 所以超时重发是比较好的选择。这种处理机制叫做：<strong>超时重传</strong>

 要实现超时重传，需要在发送完一个分组后，设置一个超时计时器，在到期时间前，如果收到了接收方的确认，就撤销已经设置的超时计时器。
 这个协议需要注意以下几点：
 1) 发送方发送一个分组之后，必须保留分组副本，以备超时重传。
 2) 分组和确认分组都必须编号，这样才能确认那个分组被确认，那些分组还没有收到确认。
 3) 超时时间大小的设定（第一需要保证，超时时间应该大于分组在M1，M2之间来回一次的时间。第二超时时间不能设置的太长，否则会降低网络传输效率）
 > 超时时间的设定问题比较复杂，如果设置的太高，会降低网络传输效率，而设置的太低，又会增加许多不必要的重传，而且分组在传输中所经过的网络是不确定的，到底网络拥塞情况如何，会产诞生多大的时延？ 这个地方我还在研究之中。

- 如果确认分组丢失：
  如果说，确认分组丢失， M1并不知道自己发送的分组到底处于什么状态（丢失，出错，M2的确认分组丢失），M1会重发分组，M2接收到M1重新发送的分组后，知道自己之前已经正确接到了，会直接丢弃该分组，不会向上层交付，然后向M1发送确认分组（并不会因为自己之前已经接到了而不重发）。
- 如果重复确认：
 如果说，M2发送的确认分组迟到了，发生了重复确认，对于重复确认的处理比较简单:直接丢弃，M2仍然能收到重复的分组，然后重复上述过程。

上述两个过程，即为被称为：自动重传请求ARQ

> 如果M1总是不能收到确认信息，说明网络太差，不能进行通信。

经过上面的过程，我们就能在不可靠的通信基础上，实现可靠通信。

> 虽然通过上述协议能实现可靠通信，但是在M1等待确认分组这个时间段内，信道是空闲的， 发送与等待中的时间，主要为网络情况所决定，在等待确认时间很长时，信道利用率就会降低，所以，停止等待协议并不完美。

## 流水线传输及 连续ARQ协议和滑动窗口协议
流水线传输的主要思想为：不必在发送完一个分组后就停下来等待确认，而是一口气发送多个分组，这样一来，在每时每刻，信道都会处于忙碌状态，从而提高信道利用率。

而流水线传输就需要用到：连续ARQ协议及滑动窗口协议

### 连续ARQ协议的基本概念
例：我现在有一百个分组依次编号从小到大排列等待发送；

- 发送方

窗口：

我的窗口值设置为5，则覆盖到分组序列中的前五个都能同时发送出去
如果五个分组中的第一个分组收到了确认，就将窗口向前滑动一位，则现在分组序列中的第6个分组就能开始发送了。

- 接收方：
接收方采用累积确认的方式，比如说，接收方等待五个分组都收到后，对<strong>按序到达的最后一个分组发送确认</strong>。 发送方收到这个分组的确认后，就知道前面的分组都收到了，就会将窗口向前滑动。

如果说发送的 1~5的分组中，丢失了第三号分组，那么接收方只会发送第二号分组的确认消息，而发送方会重发第三号到第五号分组；
> 这种方式好的地方是实现起来简单，确认丢失也不用重传（这一句在计算机网络中看到，但还是不是很理解）， 不好的地方是，接收方无法向接收端反映所有的分组接收信息

### TCP首部
> 首部较UDP要复杂的多，但是只有掌握了TCP首部的各个字段的作用，才能深入理解TCP协议
TCP报文段分为首部及数据段
首部前二十个字节是固定的。
后面有4n个字节是根据需要而增加的选项。
（所以TCP首部的最小长度为20 Byte）

|  名称   |  大小（单位：Byte） | 解释 |
|  ----  | ----  | ---- |
| 源端口号  | 2 | 发送端所用的端口号 |
| 目的端口号  | 2 | 接收端所用端口号 |
| 序号  | 4 | 分组序列编号 |
| 确认号  | 4 | 确认编码 |
| 数据偏移 |  4 （位） |  数据偏移量  |
| 保留位 | 1（位） | 保留字段 |
| 紧急URG | 1位 | 下面解释 |
发送端：A
接收端：B

- 序号：
TCP是面向字节流的，TCP会对数据中的每一个字节编号，例如：
本报文段的序号字段是201，数据长度为100个字节，那么则表明，该报文的数据区域的第一个字节的序号为201， 最后一个字节的序号为300；下一个报文段应该从301开始（这个也叫报文段序号）

- 确认号
期望收到下一个报文段的数据的第一个字节序号。
例如：B收到了A发送的序号为301的长度为10的0报文，则可在确认报文的确认号里面打上401（不是301，也不是400， 而是401）这表明了接收端收到了序号到400为止的数据，总结为：

若：确认序号= N， 则表明，接收端收到了 到 N-1 为止的所有数据。
序号占4个字节，32位，可给4Gb的数据编号，一般不用考虑序号重复的问题，当序号开始回到1时，旧的1早就已经发送完成了。

- 数据偏移
指出TCP报文数据段起始处距离TCP报文起始处有多远。这个字段实际上就规定了TCP首部的长度。由于该段所占长度为4个位 最大能表示的十进制数为15， 数据偏移的单位是 32位字，即四个字节，所以偏移量能表示的最大为： 15 *4 = 60 字节； 由于默认的TCP头部长度为20字节，所以，自定义的首部字段总长度不能超过40个字节。

- 保留位
占6位，留作后续使用， 目前置为0。

- 紧急URG
当为1时，表明紧急指针字段有效， 表明该报文中有紧急数据，应当尽快发送（表示为优先级较高的报文）不要再按照之前的排序。
需要与紧急指针字段配合使用。

- 确认ACK
当为1时 ACK才有效，当ACK为0时，确认号无效，TCP规定，连接建立后，所有的报文，ACK都置为1；

- 推送PSH（push）
两个进程通信时，如果发送方希望在键入一个命令后，接收方能够立即响应，就将这个字段置为1，接收方收到之后发现PSH为1，会立即将报文交付给进程，而不用将数据存入缓存一起交付。（很少使用）

- 复位 RST
当RST为1时，表明TCP连接出现了严重的差错，必须释放连接，然后重新建立连接，还可以拒绝一个非法的报文段或拒绝打开一个连接.

- 同步SYN
用来建立连接时同步序号, 当SYN = 1 而ACK = 0时代表这是一个连接请求报文段，若对方同意建立连接，则应该设置 SYN = 1， ACK = 1，

- FIN
当FIN = 1时，表明该报文段已经发送完成，要求释放已经建立的连接。

- 窗口
两个字节, 是从0 开始的一个整数，窗口指的是发送本报文段的一方的接收窗口，窗口告诉对方，从确认号算起，接收方允许对方发送的数据量；
例如： 窗口值为1000， 确认号为 301， 这就表明，从301号算起，发送此报文段的一方还有接收1000个字节数据（字节序号是301～1 300）的接收缓存空间。
窗口值明确指明了现在允许对方发送的数据量，窗口值是时长动态变化的。

- 检验和
两个字节，检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式与UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6 （TCP的协议号是6），把第5字段中的UDP长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6，则相应的伪首部也要改变。

- 紧急指针

- 选项
